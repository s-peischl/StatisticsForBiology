---
title: "Lecture Notes for Statistics for Biology FS2020"
author: "Stephan Peischl"
date: "1/10/2020"
output:
  html_document:
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

These notes should help you get started with the statistics software R, guide you through the practical part of the course and provide additional information on selected topics. Before you continue reading, make sure you have R and R Studio installed on your computer. Try to use R as an calcualtor as shown in the lecture slides and try to get yourelf acustomed to the different windows in the RStudio envrionment. No prior knwoledge about R is necessary and once everything is up and running yu can dive right in.

We start by loading some relevant packages for this course. An R package is a collection of functions, data, and documentation that extends the capabilities of base R. 

```{r libraries.eval,echo = TRUE,results='hide', message=F, warning=F}
# make sure you have th packages installed using 
# install.packages(packagename)

library(tidyverse)
library(Rmisc)
library(tibble)
library(dplyr)
```



# Visualizations with ggplot2

We start with some examples of how to visulaize data quickly and easily. This should show you how to produce high quality visulaizations using R and motivate you to learn more about programming and data analysis with R. 

R has several systems for making graphs, and I have chosen to start with ggplot2 beacuse it is elegant, versatile and is easy to leanr if you have no prior knowledge about programming. For those of you who are already familiar wiht programming langauges, doing graphics in "base R" may seem more intuitive initially but I hope I can convince you that the grammar of plotting used by ggplot has lots of advantages and is very readable once you get the hang of it. 

If you’d like to learn more about the theoretical underpinnings of ggplot2 before you start, I’d recommend reading “The Layered Grammar of Graphics”, http://vita.had.co.nz/papers/layered-grammar.pdf.

### The MPG dataset
Let’s use our first graph to answer a question: Do cars with big engines use more fuel than cars with small engines? What does the relationship between engine size and fuel efficiency look like? Is it positive? Negative? Linear? Nonlinear?

We can find an answer with the mpg data set found in ggplot2 (aka ggplot2::mpg). A data frame is the R data format to store data in the format of a spreadsheet: rectangular collection of variables (in the columns) and observations (in the rows). mpg contains observations collected by the US Environmental Protection Agency on 38 models of car.

```{r dataframe}
mpg
```

Among the variables in mpg are:



**displ**, a car’s engine size, in litres.

**hwy**, a car’s fuel efficiency on the highway, in miles per gallon (mpg). A car with a low fuel efficiency consumes more fuel than a car with a high fuel efficiency when they travel the same distance.



To learn more about mpg, open its help page by running ?mpg. in the next seciton we learn how to visualize such data.




### The grammar of ggplot2
In general you begin a plot with the function *ggplot()*. ggplot() creates a coordinate system that you can add layers to. The first argument of ggplot() is the dataset to use in the graph. For instance, typing ggplot(data = mpg)
into the console creates an empty graph (which is boring so it is not shown here). You can now add layers to your plot. For example, the function geom_point() adds a layer of points to your plot creating a a scatterplot.

```{r mileage}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) 
```

There are many other such *geometric functions* withing the ggplot2 universe and you can combine them in a single plot.  You’ll learn a whole bunch of them throughout this course, but be aware that we will only scratch the surface of what is available. After this course, you should be equipped with everthing you need to equip your self with new tools for data analysis whenever you need them.

Each geom function in ggplot2 takes a mapping argument. This defines how variables in your dataset are mapped to visual properties. The mapping argument is always paired with aes(), and the x and y arguments of aes() specify which variables to map to the x and y axes. ggplot2 looks for the mapped variables in the data argument, in this case, mpg.

Next, we use a different theme beacuse this gray background in the standard design is ugly.

```{r mileage2}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  theme_classic()
```

The general grammar of ggplot is

ggplot(data = \<DATA\>) + 

 \<GEOM_FUNCTION\>(mapping = aes(\<MAPPINGS\>))
  
We will explain each part step by step in examples. The DATA argument should be quite clear: here you specify the dataframe (we will learn more about that alter) that you want to work with.

The second part, GEOM_FUNCTION, specifies what kind of plot you want. As mentioned above *geom_point* gives you a classic scatter plot. Many other such funtions exist and we will encounter some of them. 

Finally, MAPPING specifies which variables hould be plotted. We ussually specify this with an aesthetics mapping of the form mapping = aes(x = ..., y =...) to deterimne the variables that give us the x- and y-coordinates. We can however also change the aesthetics of our plot in various way, for instance by giving data points different colors that indicate the value of a third variable:  
```{r mileage_aes}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy,color = class)) +
  theme_classic()
```

Another important option is to set a clor manually:
```{r mileage_aes_2}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue") +
  theme_classic()
```

As a final remark, you can also create a plot, store it in a variable and then explore themes after that:

```{r mileage_aes_themes}
p = ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue") 

p+theme_classic()
p+theme_dark()
```


## Base R graphics

Base R refers to the standard R functions. While ggplot allows us to make sophisticated graphs very quickly, I find that in some situations base R is just as good or even better. Let us recreate the same plot as before:

```{r}
plot(mpg$displ,mpg$hwy) 
```
 
Note how we use the $ symbol to access the variables stored in a data frame here; it allows you to access a specific column of a data frame. 
Try typing the name of a dataframe, followed by the $ operator in RStudio; it should automatically suggest you the availbale variable names in your data frame.  

We can alos add stuff to this plot, change colors, and pretty much everything else we would like to. A quikc look at the help function should give you an overview about the scope of the function plot and it's parameters. For instance, have a look at the following plot, where I first make a scatterplot and modifiy the appearance of the symbols, add some labels and a title, and then add a horizontal line at the value of the median fuel efficiency:

```{r}
plot(mpg$displ,mpg$hwy,pch=16,col="darkblue",xlab="displ",ylab="hwy", main ="a scatterplot")
abline(h = median(mpg$hwy))
```

When working with data frames, ggplot may seem more attractive and easy to use than base r, simply because many steps are automated. You may want to try colro-coding the different points according to the varibale class, just as we did before. Then try to add a legend (look up the function *legend* in the R help). You will find out that it may be a bit tedious to put all this things together. However, it also gives you a lot of control about the final looks of your figure. Another advantge of base R function is that you are not restircted to the data frame format, which often makes things easier. For instance, consider this plot:

```{r}
x=seq(0,7,by=0.1)   
# x = (0,0.1,0.2,0.3, … ,6.9,7)
y=sin(x)


plot(x,y,lwd=2,type="l",col="deepskyblue4",axes=FALSE) 
#plot without axes

axis(1) #add axes to plot
axis(2)

text(2.8,0.85,"y = sin(x)",col="deepskyblue4")   
# add some text at coordinates x = 2.8, y = 0.85

lines(x,cos(x),lwd=2,col="green4")  # add a cosine plot …
text(1.5,-0.5,"y=cos(x)",col="green4")   # … and label it

legend(3.5,0.8,legend=c("y=sin(x)","y=cos(x)"),
col=c("deepskyblue4","green4"),lwd=2)   
# add a legend to the plot
```
Instead of using a data frame, we have created vectors of variables and used them in several different ways. You will explore this more in the exercise sessions.

By now you should see that R is very versatile. This course will teach you the basics of R so that you can start using it for your research projects. An essential part is that  you should also learn how to find and use additional resources, such as the help function in R, books, the internet, etc. Nobody knows all of R - it is an ever growing community endevaour and looking up how things work, which functions or packages are available, or how other people solved a problem is an essential part of learning to be proficient in R.

# Loading datasets
How to we feed R our data? Of course, we can jsut type it into the console, a bit like in the previous base R graphics example. However, for large data sets this is not practical. We want to load our data from a file, which makes our analysis easily reproducible if we share data and the script with someone. First we need to make sure R knows where our working directory is, using the function *setwd* (set working directory):
```{r}
setwd("/Users/stephan/Dropbox/Teaching/StatisticsForBiology/")
```
If you want to check your current working directory, you can do this with *getwd()*.

I use a dataset about the number of plates on sticklebacks. You can find this dataset (and many others) on ilias. We can load a dataset using the function *read.csv* and store it in the variable stickleback
```{r}
stickleback = read.csv("chap03e3SticklebackPlates.csv")
```

The variable *stickleback* now contains a so called data frame.  We can have a quick summary of the content of this data frame using the command *str* (short for *STR*ucture):

```{r}
str(stickleback)
```

We can see form the output that we have 344 observations (= sample size) and for each individual we have measured 3 variables (id, plates and genotypes). ID and genotpye are so-called factors, that is, a catergorical variable and plates is of type integer.  

We used the function *read.csv* because our data is stored in the csv format (short for comma seperate values - open the csv file to see what that means). CSV is a common format and you can export your data from software like Excel in that format. Of course, R provides functions for other formats as well. 

Let us use our ggplot skills to create a nice figure that visualizes our data set. For this we introduce the fucntion *geom_bar()* which allows us to make a bar plot of the number of plates per indivudal, colored by genotype:
```{r}
ggplot(data = stickleback) + 
  geom_bar(mapping = aes(x = plates,color=genotype)) + 
  theme_classic()
```

This figure is a bit messy. A better way would be to show the distribution for each genotype in its own window. This can be done using the function *facet_wrap*. As before, we can simply add this to our ggplot command:

```{r}
ggplot(data = stickleback) + 
  geom_bar(mapping = aes(x = plates),fill="darkred") + 
  facet_wrap(~genotype,nrow = 3) +
  theme_classic()
```

We used a new symbol here: the ~. This is part of an R object called formula and it will alter become clear why we used it here like this. For now, just remeber to use it in front of the varibale name in facet wrap. The second aprameter is simply the number of rows in the plot. Try changing it and see what happens. Note: the variable that you pass to facet_wrap shoudl **always** be categorical!


## Manipulating data frames
A data frame is essentially a spreadsheet or a table (or rather a matrix). Therfore, we acess each column or each row, if we want to. This can be done using the *[,]* symbols. The element in row 3 and column 5 is given by:
```{r}
stickleback[3,5]
```
the whole 3rd column can be accesses by 
```{r}
stickleback[,3]
```
and the 5th row by
```{r}
stickleback[5,]
```
Note that stickleback[[,3]] gives you all measurment of the 3rd variable in our dataframe and is hence equivalent to stickleback$genotype. The vector stickleback[5,] on the other hand gives you a vector with the 3 measured values of the 5 th individual. 

We can also use this way of accessing elements to find elements of a certain type, for instance, fi we want to know the genotype of all individuals with more then 30 plates, we can get this in the following way:
```{r results = "hide"}
stickleback[stickleback$plates>20,3]
```
Try to understand what is happening here by teasing apart and investigating the differnt parts of this (nested) command. What would happen if you removed the *stickleback$plates>20* from the command, or the *3*. 

A slightly more elegant way to get this is by using the function *filter* (make sure you have the package dyplr loaded!):
```{r results = "hide"}
filter(stickleback,plates>20)
```
which gives ou a data frame with only the individuals that satisfy the condition set in the argument.

## Descriptive Statistics 

We continue using the stickleback data set and calcualte some statistics on it. A simple way to get a quick overview about the properties of your data frame is using the funciton *summary*:

```{r}
summary(stickleback)
```

If you want to calcualte a specific statistic, like the mean of a variable, this can be done easily:

```{r}
mean(stickleback$plates)
```

You may have noticed that we have no calcualted the mean number of plates for *ALL* fish in our data set. What if we want to calcualte the number of plates for a specific genotype? We can use the function filter:

```{r}
stickleback.mm = filter(stickleback,genotype=="mm")
mean(stickleback.mm$plates)
```

You could now calcualte the mean plate numbers for each genotpye in this way: 

```{r}
mean.mm = mean((filter(stickleback,genotype=="mm"))$plates)
mean.mM = mean((filter(stickleback,genotype=="mM"))$plates)
mean.MM = mean((filter(stickleback,genotype=="MM"))$plates)
```


**Note:** The tidyverse offers  an elegant way to write a long series of commands in a very readable format. To show you how to combine multiple commands quickly, we first need two more functions,  *group_by* and *summarize*, and a new operator called the pipe: %>%  (because we create a pipeline thorugh which our data "flows"). The above code to calculate the mean for each genotype would become:
```{r}
stickleback %>% 
group_by(genotype) %>%
summarise(avg = mean(plates))
```
This is very readable: you take the dataframe stickleback, group it by genotye and summarize it by calcualting the mean number of plates. However, errors might be more difficutl to spot when the code is written in that way, as intermediate steps cannot be checked.

In the exercises you will learn a few more useful functions to rearrange, filter, extend and edit data frames.

*Question: Can you come up with anotehr way to do this whithout using filter? *

*An answer (there are many ways to do this):*
```{r}
mean.mm = mean(stickleback$plates[stickleback$genotype=="mm"])
mean.mM = mean(stickleback$plates[stickleback$genotype=="mM"])
mean.MM = mean(stickleback$plates[stickleback$genotype=="MM"])
```

*Question: Can you plot a histogram of plate numbers of individuals with genotpye mm using base R plotting functions? Hint: Use waht yu have learned here and look up the functionhist().*

*Answer:*
```{r}
hist(stickleback$plates[stickleback$genotype=="mm"],col="darkred",xlab="plates",main="Genotype: mm")
```

## Adding variables to data frames (mutate)

Sometimes we wish to extend our dataframe with calcualtions we did during our analysis or with additional measurements. This can be done with the function *mutate()*. It simply adds new columns at the end of your dataset. Let's say we want to identify which indivduals have fewer or more plates as comapred to the global mean:
```{r}
diff.to.mean = stickleback$plates - mean(stickleback$plates)
stickleback2 = mutate(stickleback,difference = diff.to.mean)
head(stickleback2)
```



*Questions:*

*Add a new varaible to the stickleback data frame that contains the difference between plate number and the mean plate number for that individuals genotype.

*Load the flights dataset:
```{r}
library(nycflights13)
```
Find all flights that

** Had an arrival delay of two or more hours

** Flew to Houston (IAH or HOU)

** Were operated by United, American, or Delta

** Departed in summer (July, August, and September)

** Arrived more than two hours late, but didn’t leave late

** Were delayed by at least an hour, but made up over 30 minutes in flight

** Departed between midnight and 6am 

Hint: look up logical operators!


# A bit of workflow
In this part you will see how to explore a data set and store your analysis in a reproducible and reusable way.  

## What is an R script

So far we only used the console of R. We enter commands and R executes them. Most of the time we want to have a whole bunch of commands stored in a single space: loading the file, preparing and cleaning the data,make figures, etc. The solution is easy, we jsut store our commands in a text file with the extension *.R* and tell R do execute this script. Evene better, RStudio has its own window panel for writing and executing scripts! Try to open a new R script (via File -> New -> R script) and just write your code in the newly opened window. When you have written your code, you can eitehr execute it step by step by putting the mouse cursor in the line you want to execute and then hit then *Run* button. If you want to eecute the whole script from beginning to end, just hit the *Source* button. This allows you to make reproducible scripts than you can modify and reuse whenever you need to. This is probably the biggest advantage of R. Once you have solved a problem and wrote a script for it, you can always reuse it. The more you use R, the less work will be necessary for each new project! 


In the next part I will introduce the basic tools for creating an automated analysis that consists of several steps.

## Defining and using Variables

Defining variables is really easy in R. Unlike in other programming languages we do not need to precisly define what kind of variable we want. We can just werite down a name and assign a value, R figures out the rest. For instance:

```{r}
x = 5
```

automatically creates a *numeric* variable and assigns the value 5 to it. This command

```{r}
vec = c(1,2,3,4,5,6)
```

creates a vectors that contains the values 1 to 6. The *c* here stands for *concatenate* and tells us to combine all the numbers into a single vector. You can access the elements of the vector by their index, e.g., we can set the 5th element of the vector to 0 in the follwoing way:
```{r}
vec[5] = 0 
```

In general it is advised to define the type of a varible before using it, and also tell R how big this variable will be (that is, how much memory we need to reserve to store it). For instance, if we want to define a 3x4 matrix we can use the command *matrix*:
```{r}
mat=matrix(ncol=3,nrow=4)
```

You can then enter numbers in the rows and columns using the [] operator:

```{r}
mat
mat[2,3]= 5 
mat
```
You can see that the matrix is intially filled with the object *NA* which stands for *not available* and ist the term R uses for missing data. Just like in dataframes (after all a data frame is more or less a matrix with benefits), you can also name columns and rows and use them to access the elements:


```{r}
mat = matrix(1:25,nrow=5,ncol=5)
colnames(mat) = c("var1","var2","var3","var4","var5")
rownames(mat) = c("obs1","obs2","obs3","obs4","obs5")
mat
mat["obs2",]
mat[,"var3"]
mat["obs2","var3"]
```



If we want to store some text, we can write
```{r}
word = "hello"
```
and R will automatically recognize that the string of letters "hello" is not numeric and will creat a variable of type *character*. Try to see how this is different from 

```{r}
letters = c("h","e","l","l","o")
```

Next try to see what happens here:
```{r}
hello = 10
word1 = "hello"
word2 = hello
print(word1)
print(word2)
```





## Loops

Before we have seen how to calcualte the mean number of plates for each genotype. Essentially we have done the same thing 3 times. Imagine we woul dhave hundreeds of genotypes. In such situations loops come in handy. They allow us to automate a process that needs to be repeated many times. We only introduce the so-called *for-loop* here, which will allow you to do a lot of things. Once you have understood how it works, it will be easy to figure out how a *while-loop* works and what the differences are.

Here is a simple for loop that calcualtes the mean number of plates for each genotpye in our stickleback data set:

```{r}

# first we create a vector that contains all genotpyes in our dataset
# we can do this manually: 
# genotypes = c("mm","mM","MM")
# or by using the function levels()
# that gives us a vector with all the different entries found in a 
# vector of type factor

genotypes = levels(stickleback$genotype)

# next, we define a vector that has the same length as the number 
# of different genotypes and name the elements accordingly

plate.numbers = vector("numeric",length(genotypes)) 
names(plate.numbers)=genotypes

# no comes the actual loop:
for(g in genotypes)
{
  plate.numbers[g]=mean(stickleback$plates[stickleback$genotype==g])
}

```

We can see what is happening here by showing the intermediate steps more explicitly:

```{r}
i = 1
for(g in genotypes)
{
  print(paste("This is iteration ",i," of our for-loop"))
  print(paste("Genotype ",i," = ",g))
  mean.temp = mean(stickleback$plates[stickleback$genotype==g])
  print(paste("The mean number of plates of genotype ",g," is ",mean.temp))
  plate.numbers[g]=mean.temp
  i = i+1
}

```

There are 3 basics steps here:

* Reserve memory for the output
* Set up how often the loop should be iterated
* The code that should be repeatedly calcualted


*Question: Could you come up with an alterantive way to solve this problem using a loop?*


## If / else


## Functions

# Distributions

## Visualizing distributions 
We can visualize continous data in a histogram, for instnace how many cars we have in each class:

```{r}
ggplot(data = mpg) + 
  geom_bar(mapping = aes(x = class))
```

We can make stacked graphs using the argument $fill$ and a discrete variable such as number of cylinders 

```{r}
ggplot(data = mpg) + 
  geom_bar(mapping = aes(x = class, fill = as.factor(cyl)))
```

If we want to show the distribution of a continous variable for each class, we can do boxplots, e.g., showing the mileage of each class
```{r}
ggplot(data = mpg) + 
geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) + 
coord_flip()
```



Another way of summarizing data is by showing several statistics using whisker plots. A simple solution is using the stat_summary function. In the example below the dots show the median, and the whiskers extend to the minium and maximum in each category (class).

```{r}
ggplot(data = mpg) + 
  stat_summary(
    mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy),
    fun.ymin = min,
    fun.ymax = max,
    fun.y = median
  ) +
  coord_flip()
```

If we want to show confidnece intervalls (or any otehr quantity), a clean way to do this is to simply create a data set containing this information and then use it to plot the quantitites.

```{r}

mpgSE <- summarySE(mpg, measurevar="hwy", groupvars=c("class"))

mpgSE

ggplot(mpgSE, aes(x = reorder(class, hwy, FUN = median), y = hwy)) + 
    geom_errorbar(aes(ymin=hwy-ci, ymax=hwy+ci), width=.1) +
    geom_point() +
    coord_flip()
```







# Hypothesis Tests

## Binomial-test, t-test

# Deviations from Normailty

## QQ Plots

## Transformations

## Non-Parametric Alterantives

## Permutation Test

# Testing for independence

## Chi-square test

# ANOVA

# Linear Regression

 whereas geom_smooth would give you a smooth line theat best resembles the cloud of points (more on  that later):

```{r mileage3}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy)) +
  theme_classic()
```

Of course, we can put points and a smooth line on the same plot: 
```{r mileage4}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy)) +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  theme_classic()
```

You may wonder how the smooth line is determined. We will come back to this later in the chapter on linear regression. For now, we just mention that we can modify the method used for the plot, e.g., to get a linear regression line:
```{r mileage_lm}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy),method='lm') +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  theme_classic()
```